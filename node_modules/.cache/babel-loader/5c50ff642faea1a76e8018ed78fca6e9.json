{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}(); //     node-react-native-fetch-api\n//     Copyright (c) 2015- Nick Baugh <niftylettuce@gmail.com>\n//     MIT Licensed\n// * Author: [@niftylettuce](https://twitter.com/#!/niftylettuce)\n// * Source: <https://github.com/niftylettuce/node-react-native-fetch-api>\n// # node-react-native-fetch-api\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar debug = (0, _debug2.default)('fetch-api');\nvar fetch = typeof window === 'undefined' ? global.fetch : window.fetch;\nif (!fetch) throw new Error('fetch is required, use `whatwg-fetch` or `node-fetch`');\nvar methods = ['get', 'head', 'post', 'put', 'del', 'options', 'patch'];\n\nvar Api = function () {\n  function Api(opts) {\n    var _this = this;\n\n    _classCallCheck(this, Api);\n\n    this.opts = opts || {};\n    if (!this.opts.baseURI) throw new Error('baseURI option is required');\n    this.headers = _extends({}, opts.headers, {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    }); // support `auth` being an array or a string\n    // and if it is a string and contains ':'\n    // then split on that and only return 2 keys\n\n    if (this.opts.auth) this.auth(this.opts.auth);\n    methods.forEach(function (method) {\n      _this[method] = _this._setup(method);\n    });\n  }\n\n  _createClass(Api, [{\n    key: '_setup',\n    value: function _setup(method) {\n      var that = this;\n      return function (path, options, callback) {\n        // TODO: path must be string\n        if (typeof options === 'function') {\n          callback = options;\n          options = {};\n        } // TODO: callback must be a function\n\n\n        var opts = _extends({\n          headers: _extends({}, that.headers)\n        }, options, {\n          method: method === 'del' ? 'DELETE' : method.toUpperCase()\n        });\n\n        var res = undefined;\n        fetch(that.opts.baseURI + path, opts).then(function (_res) {\n          res = _res;\n\n          try {\n            _res = _res.json();\n          } catch (e) {\n            _res = _res.text();\n          } finally {\n            return _res;\n          }\n        }).then(function (body) {\n          callback(null, res, body);\n        }).catch(function (err) {\n          callback(err);\n        });\n      };\n    }\n  }, {\n    key: 'auth',\n    value: function auth(creds) {\n      if (typeof creds === 'string') {\n        var index = creds.indexOf(':');\n\n        if (index !== -1) {\n          var split = creds.split(':');\n          creds = [split.slice(0), split.slice(index, split.length)];\n        } else {\n          creds = [creds];\n        }\n      }\n\n      if (!creds instanceof Array) throw new Error('auth must be an array or string');\n\n      switch (creds.length) {\n        case 0:\n          creds = new Array('', '');\n          break;\n\n        case 1:\n          creds.push('');\n          break;\n\n        case 2:\n          break;\n\n        default:\n          throw new Error('auth option can only have two keys `[user, pass]`');\n      }\n\n      if (typeof creds[0] !== 'string') throw new Error('auth option `user` must be a string');\n      if (typeof creds[1] !== 'string') throw new Error('auth option `pass` must be a string');\n      if (creds[0] === '' && creds[1] === '') delete this.headers.Authorization;else this.headers.Authorization = 'Basic ' + new Buffer(creds.join(':')).toString('base64');\n    }\n    /*\n        get(path, fn) {\n          fetch(that.opts.baseURI + path, {\n            method: 'GET',\n            headers: that.headers\n          })\n          .then((res) => {\n            try {\n              let response = JSON.parse(res);\n              if (response && response.error)\n                throw new Error(response.error);\n              return res.json();\n            } catch (e) {\n              return res.text();\n            }\n          })\n          .then((res) => {\n            fn(null, res);\n          })\n          .catch((err) => {\n            fn(err);\n          })\n        },\n        post(path, data, fn) {\n          if (!fn)\n            fn = data;\n          fetch(that.opts.baseURI + path, {\n            method: 'POST',\n            body: JSON.stringify(data),\n            headers: that.headers\n          })\n          .then((res) => res.json())\n          .then((res) => {\n            if (res && res.error)\n              return fn(res.error);\n            fn(null, res);\n          })\n          .catch(fn)\n        },\n        put(path, data, fn) {\n          fetch(that.opts.baseURI + path, {\n            method: 'PUT',\n            body: JSON.stringify(data),\n            headers: that.headers\n          })\n          .then((res) => res.json())\n          .then((res) => {\n            if (res && res.error)\n              return fn(res.error);\n            fn(null, res);\n          })\n          .catch(fn)\n        },\n        delete(path, data, fn) {\n          fetch(that.opts.baseURI + path, {\n            method: 'DELETE',\n            headers: that.headers\n          })\n          .then((res) => res.json())\n          .then((res) => {\n            if (res && res.error)\n              return fn(res.error);\n            fn(null, res);\n          })\n          .catch(fn)\n        }\n      };\n    }\n    */\n\n  }]);\n\n  return Api;\n}();\n\nexports.default = Api;","map":null,"metadata":{},"sourceType":"script"}